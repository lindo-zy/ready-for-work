# ready-for-work
some python interview questions

------

1.python中一切皆对象

```
python中类型是属于对象的，而不是变量的。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。
```

2.__new__和__init__的区别

```
__new__是一个静态方法,而__init__是一个实例方法.
__new__方法会返回一个创建的实例,而__init__什么都不返回.
只有在__new__返回一个cls的实例时后面的__init__才能被调用.
当创建一个新实例时调用__new__,初始化一个实例时用__init__.
```

3.python的垃圾回收机制

```
Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。

1 引用计数
PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。

优点:

简单
实时性
缺点:

维护引用计数消耗资源
循环引用
2 标记-清除机制
基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。

3 分代技术
分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。
```

4.select、poll、epoll

```
select、poll、epoll都是IO多路复用机制。
select有三大缺点：
（1）连接数受限
（2）查找配对速度慢
（3）数据由内核拷贝到用户态

poll改善了第一个缺点

epoll改善了全部缺点
```

5.操作系统调度算法（根据系统的资源分配策略所规定的资源分配算法）

```
（1）先来先服务(FCFS, First Come First Serve)
	适合CPU密集型作业，不利于IO密集型作业
（2）短作业优先(SJF,Shortest Job First)
	对长作业不利，作业的长短是估算出来的
（3）最高优先权调度(Priority Scheduling)
（4）时间片轮转（RR，Round Robin）
（5）多级反馈队列调度(MFQS,multilevel feedback queue scheduling)

实时调度算法：
（1）最早截至时间优先（EDF）
（2）最低松弛度优先(LLF)
```

6.页面置换算法

```
（1）最佳置换算法(OPT)
（2）先进先出（FIFO）
（3）最久未使用(LRU)
（4）Clock置换算法
```

7.死锁

```
产生原因：
（1）竞争资源
（2）程序推进顺序不当
必要条件：
（1）互斥条件
（2）请求和保持条件
（3）不剥夺条件
（4）环路等待条件
处理死锁基本方法：
1.预防死锁
2.避免死锁（银行家算法）
3.检测死锁（资源分配图）
4.解除死锁：
（1）剥夺资源
（2）撤销进程
```

8.三次握手

```
（1）客户端->SYN->服务端
（2）服务端->SYN/ACK->客户端
（3）客户端->ACK->服务端
```

9.四次挥手

```
（1）客户端->FIN->服务端
（2）服务端->ACK->客户端
（3）服务端->FIN->客户端
（4）客户端->ACK->服务端
```

10.GET和POST

```
1.GET使用URL或Cookie传递参数，POST将数据放在BODY中
2.GET的URL在长度上会有限制，POST一般没有限制
3.POST比GET要安全，因为数据在地址栏不可见
4.GET一般用于获取数据，POST用于提交数据
```

11.Cookie和Session

|          | Cookie                             | Session  |
| -------- | ---------------------------------- | -------- |
| 存储位置 | 客户端                             | 服务端   |
| 目的     | 跟踪会话，保存用户设置，账号密码等 | 跟踪会话 |
| 安全性   | 不安全                             | 安全     |

12.apache和nginx

| apache     | nginx                                                        |
| ---------- | ------------------------------------------------------------ |
| rewire强大 | 轻量级，占用资源少                                           |
| 模块多     | 抗并发，异步非阻塞，支持更多的并发连接，高并发下保存资源低消耗高性能 |
| BUG少      | 配置简单，高度模块化设计                                     |
| 稳定性高   | 社区活跃                                                     |

13.CSRF和XSS

```
CSRF跨站请求伪造（拼接url）
XSS跨站脚本攻击（拼接js）
```

14.OSI七层模型

| 层次 | 名称       | 功能                                                 |
| ---- | ---------- | ---------------------------------------------------- |
| 7    | 应用层     | 针对特定应用的协议                                   |
| 6    | 表示层     | 设备固有数据格式和网络标准数据格式的转换             |
| 5    | 会话层     | 通信管理。负责建立和断开通信连接，管理传输层以下分层 |
| 4    | 传输层     | 管理两个节点间的数据传输，负责可靠传输               |
| 3    | 网络层     | 地址管理与路由选择                                   |
| 2    | 数据链路层 | 互联设备之间传送和识别数据帧                         |
| 1    | 物理层     | 界定连接器和网线规格                                 |

15.路由

```
分组从源头到目的地时，决定端到端路径的网络范围的进程。
路由工作两个基本：
（1）确定最佳路径
（2）通过网络传输信息
```

16.排序算法

| 名称                  | 最坏时间    | 最好时间    | 平均时间    | 类型       |
| --------------------- | ----------- | ----------- | ----------- | ---------- |
| 插入排序(insert_sort) | O(n^2)      | O(n)        | O(n^2)      | 稳定算法   |
| 冒泡排序(bubble_sort) | O(n^2)      | O(n)        | O(n^2)      | 稳定算法   |
| 选择排序(select_sort) | O(n^2)      | O(n)        | O(n^2)      | 不稳定算法 |
| 快速排序(quick_sort)  | O(n^2)      | O(n*logn)   | O(n*logn)   | 不稳定算法 |
| 归并排序(merge_sort)  | O(n*logn)   | O(n*logn)   | O(n*logn)   | 稳定算法   |
| 基数排序(radix_sort)  | O(nlog(r)m) | O(nlog(r)m) | O(nlog(r)m) | 稳定算法   |

